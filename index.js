const questions = [
    {
 "question": "Which of the following best describes a framework?",
 "answers": [
   "It provides utility functions only",
   "You control the program flow entirely",
   "It calls your code and manages the flow",
   "It cannot be extended at all"
 ],
 "correct": 2
},
{
 "question": "Why do developers use frameworks?",
 "answers": [
   "To complicate development",
   "To avoid community support",
   "To save time and reuse code",
   "To write everything from scratch"
 ],
 "correct": 2
},
{
 "question": "Frameworks help reduce development time by:",
 "answers": [
   "Offering pre-built components and structure",
   "Avoiding reusable code",
   "Providing low-level hardware access",
   "Limiting customization options"
 ],
 "correct": 0
},
{
 "question": "Which is true about frameworks compared to libraries?",
 "answers": [
   "Frameworks don’t allow extension",
   "Frameworks manage the main flow and call your code",
   "Libraries call your code",
   "Frameworks are easier to write from scratch"
 ],
 "correct": 1
},
{
 "question": "One downside of using a framework is:",
 "answers": [
   "You must follow its structure and limitations",
   "It provides no default features",
   "You always understand the full programming language deeply",
   "You can rewrite the core"
 ],
 "correct": 0
},
{
 "question": "What is one major advantage of using a framework?",
 "answers": [
   "No support for updates",
   "You must code everything manually",
   "Easier debugging and code reuse",
   "Decreased speed of development"
 ],
 "correct": 2
},
{
 "question": "What might be a problem if the wrong framework is chosen?",
 "answers": [
   "Better user experience",
   "Increased performance",
   "Negative impact on performance and UX",
   "None of the above"
 ],
 "correct": 2
},
{
 "question": "Which statement is true about framework updates?",
 "answers": [
   "You must keep up with new/deprecated features",
   "Updates always remove bugs",
   "They never change features",
   "You can skip updates without issues"
 ],
 "correct": 0
},
{
 "question": "What is ‘Inversion of Control’ in a framework?",
 "answers": [
   "Control of the application flow is given to the framework",
   "The code is written in reverse",
   "The framework only supports reverse loops",
   "User defines the entire flow"
 ],
 "correct": 0
},
{
 "question": "What’s a key limitation of frameworks?",
 "answers": [
   "Full freedom in design",
   "Can't tweak core functionalities easily",
   "Lack of default behavior",
   "Easy learning curve"
 ],
 "correct": 1
},
{
 "question": "Which of these is not an advantage of using frameworks?",
 "answers": [
   "Less boilerplate code",
   "Improved security practices",
   "Accelerated development",
   "Full control over core framework logic"
 ],
 "correct": 3
},
{
 "question": "Frameworks are often large because:",
 "answers": [
   "They only contain minimal features",
   "They serve many use cases, not just one",
   "They are handwritten",
   "They require manual compilation"
 ],
 "correct": 1
},
{
 "question": "What is ‘boilerplate code’?",
 "answers": [
   "Code reused often with minimal changes",
   "Code that never runs",
   "Obsolete framework functions",
   "Binary-only code"
 ],
 "correct": 0
},
{
 "question": "Which of these is a trait of a framework?",
 "answers": [
   "No default behavior",
   "Doesn’t allow customization",
   "Can’t be extended",
   "Has extensibility features"
 ],
 "correct": 3
},
{
 "question": "Non-modifiable framework code means:",
 "answers": [
   "You can rewrite core logic",
   "You can only extend, not change, the framework",
   "You can remove all modules",
   "You can switch languages"
 ],
 "correct": 1
},
{
 "question": "A major trait of frameworks is that they usually:",
 "answers": [
   "Are open-source",
   "Come with their own control flow",
   "Require you to build everything",
   "Are built only in C++"
 ],
 "correct": 1
}
,{
 "question": "Choosing the wrong framework can result in:",
 "answers": [
   "Faster updates",
   "Poor performance and limited UX",
   "Better resource usage",
   "Easier learning"
 ],
 "correct": 1
},
{
 "question": "Which one is a Java-based framework?",
 "answers": [
   "Vue.js",
   "Spring Boot",
   "Laravel",
   "Express.js"
 ],
 "correct": 1
},
{
 "question": "Using a framework might NOT be suitable when:",
 "answers": [
   "You want structured code",
   "The project is small and needs flexibility",
   "You want to minimize development time",
   "You prefer using built-in components"
 ],
 "correct": 1
},
{
 "question": "Which of the following is common with framework-based dev?",
 "answers": [
   "Need to write all code from scratch",
   "Automatic optimization features",
   "Lack of updates",
   "No community support"
 ],
 "correct": 1
},
{
 "question": "Which one is a front-end framework?",
 "answers": [
   ".NET Core",
   "Laravel",
   "Vue.js",
   "Spring Boot"
 ],
 "correct": 2
},
{
 "question": "Laravel is a framework built using:",
 "answers": [
   "PHP",
   "JavaScript",
   "Java",
   "C#"
 ],
 "correct": 0
},
{
 "question": "Express.js is commonly used with:",
 "answers": [
   "Python",
   "PHP",
   "Node.js",
   "Java"
 ],
 "correct": 2
},
{
 "question": "A framework is best used when:",
 "answers": [
   "You want fast, structured development",
   "You need full control and flexibility",
   "You plan to write low-level drivers",
   "You are building firmware"
 ],
 "correct": 0
},
{
 "question": "What happens if a dev learns the framework but not the language?",
 "answers": [
   "The framework teaches everything",
   "They might struggle outside the framework",
   "Deep understanding of language is gained",
   "Bugs are easier to fix"
 ],
 "correct": 1
}
,
{
 "question": "Why should you follow version updates of frameworks?",
 "answers": [
   "Just for fun",
   "To avoid new features",
   "To avoid using deprecated or insecure features",
   "They never affect performance"
 ],
 "correct": 2
},
{
 "question": "Frameworks usually offer:",
 "answers": [
   "No caching mechanisms",
   "Limited performance tools",
   "Optimization for resource-heavy tasks",
   "Only front-end solutions"
 ],
 "correct": 2
},
{
 "question": "Community support in frameworks is useful because:",
 "answers": [
   "It avoids collaboration",
   "You don’t need tutorials",
   "You can get solutions and contribute",
   "Everyone writes solo"
 ],
 "correct": 2
},
{
 "question": "Frameworks improve productivity by:",
 "answers": [
   "Avoiding reusable modules",
   "Letting devs reinvent the wheel",
   "Reducing time through code reuse",
   "Removing documentation"
 ],
 "correct": 2
},
{
 "question": "Which is a benefit of using frameworks in team projects?",
 "answers": [
   "No consistent structure",
   "Randomized styles",
   "Unified structure and faster collaboration",
   "Each dev must write all parts manually"
 ],
 "correct": 2
},
{
 "question": "What should each feature have according to Git branching best practices?",
 "answers": [
   "A separate repo",
   "A dedicated branch",
   "A unique commit ID",
   "A backup zip file"
 ],
 "correct": 1
},
{
 "question": "How many people should ideally work on a single feature branch?",
 "answers": [
   "Two developers",
   "Any number",
   "Just one",
   "Depends on the feature size"
 ],
 "correct": 2
},
{
 "question": "When should a feature branch be deleted?",
 "answers": [
   "Before it's merged",
   "After it’s pushed",
   "After merging into master",
   "When tests fail"
 ],
 "correct": 2
},
{
 "question": "Why should feature branches be short-lived?",
 "answers": [
   "Easier to track updates",
   "Keeps the main branch locked",
   "To avoid stale or outdated code",
   "So Git runs faster"
 ],
 "correct": 2
},
{
 "question": "Which action helps avoid merge conflicts?",
 "answers": [
   "Working on master",
   "Never merging",
   "Merging early and often",
   "Committing once"
 ],
 "correct": 2
},
{
 "question": "What kind of code should go in the master branch?",
 "answers": [
   "Experimental",
   "Production-ready",
   "Debug logs",
   "Unmerged feature changes"
 ],
 "correct": 1
},
{
 "question": "What’s a good example of a branch naming convention?",
 "answers": [
   "fix_this_branch",
   "mybranch123",
   "feature/vishan.j/add-dark-mode",
   "temp-featureX"
 ],
 "correct": 2
},
{
 "question": "What should NOT be done directly on the master branch?",
 "answers": [
   "Create new branches",
   "Push bugfixes",
   "Develop new features",
   "Pull from remote"
 ],
 "correct": 2
},
{
 "question": "Which command keeps the history cleaner?",
 "answers": ["git stash", "git rebase", "git commit -am", "git merge"],
 "correct": 1
},
{
 "question": "When using CI/CD, what happens after a pull request is merged?",
 "answers": ["GitHub auto-archives the project", "Tests run, and code is deployed", "It’s added to the to-do list", "The repo is forked"],
 "correct": 1
},
{
 "question": "Why might Git Rebase be better than Git Merge?",
 "answers": ["Skips file staging", "Deletes all conflicts", "Adds commit history clarity", "Works faster"],
 "correct": 2
},
{
 "question": "Which one is a safer option when collaborating with others?",
 "answers": ["Git Merge", "Git Rebase", "Git Tag", "Git Ignore"],
 "correct": 0
},
{
 "question": "Why are atomic commits preferred?",
 "answers": ["They auto-deploy", "They increase performance", "They can’t be reverted", "They allow better tracking"],
 "correct": 3
},
{
 "question": "What is one key aspect of GitHub Flow?",
 "answers": ["Never using branches", "Committing directly to live server", "Multiple people working on master", "Feature branches + pull requests"],
 "correct": 3
},
{
 "question": "Why should you write good commit messages?",
 "answers": ["So you can forget the code", "To confuse the devs", "To help teammates understand changes", "To make your commits longer"],
 "correct": 2
},
{
 "question": "What should you avoid doing in a single commit?",
 "answers": ["Adding comments", "Fixing bugs", "Pushing code", "Multiple unrelated changes"],
 "correct": 3
},
{
 "question": "How often should you commit code?",
 "answers": ["Only once per feature", "As often as you make progress", "Once per day", "Only when the task is 100% complete"],
 "correct": 1
},
{
 "question": "What is the main focus of trunk-based development?",
 "answers": ["Frequent code rewrites", "Directly committing to master", "Long feature branches", "Using many branch levels"],
 "correct": 1
},
{
 "question": "Which Git strategy uses long-lived branches like develop and release?",
 "answers": ["GitFlow", "GitMono", "GitHub Flow", "DevOps Sync"],
 "correct": 0
},
{
 "question": "Why should you pull changes from origin/main before creating a new branch?",
 "answers": ["To revert old commits", "To delete old branches", "To remove bugs", "To ensure latest updates are included"],
 "correct": 3
},
{
 "question": "What is a key benefit of CI/CD pipelines?",
 "answers": ["Automated testing and deployment", "Manual deployment", "Faster code reviews", "Shorter commit messages"],
 "correct": 0
},
{
 "question": "Why is it okay to push unfinished code to remote?",
 "answers": ["It deletes the branch", "It’s considered final", "Others will finish it", "For safekeeping"],
 "correct": 3
},
{
 "question": "Where should your local branch be pushed regularly?",
 "answers": ["Remote", "Main branch", "Desktop backup", "GitHub Pages"],
 "correct": 0
},
{
 "question": "Which of the following is a branching strategy?",
 "answers": ["GitFlow", "DevDiver", "GitYolo", "BranchBoss"],
 "correct": 0
},
{
 "question": "What is a pull request?",
 "answers": ["A request to delete a branch", "A request to merge your branch into another", "A way to copy another repo", "A Git bug report"],
 "correct": 1
},
{
 "question": "What type of changes are encouraged?",
 "answers": ["Once-a-week dumps", "Small, incremental changes", "Big commits with multiple features", "Large code overhauls"],
 "correct": 1
},
{
 "question": "Why are pull requests useful?",
 "answers": ["Bypass CI/CD", "Trigger team reviews", "Avoid versioning", "Hide your code"],
 "correct": 1
},
{
 "question": "When using git rebase, what must you watch out for?",
 "answers": ["Force push blocking", "Broken branches", "Rewrite of commit history", "Commit duplication"],
 "correct": 2
}
,
{
   "question": "Which of the following reduces the chance of merge conflicts?",
   "answers": ["Large commits", "Ignoring pulls", "Frequent merges", "Manual patching"],
   "correct": 2
 },
 {
   "question": "Which of the following is NOT recommended Git behavior?",
   "answers": ["Use consistent branch naming", "Push often", "Work directly on master", "Commit often"],
   "correct": 2
 },
{
   "question": "What's a major challenge with microservices?",
   "answers": ["Slow deployment", "High global complexity", "No local changes", "Static UI"],
   "correct": 1
 },
 {
   "question": "What does 'global complexity' in microservices refer to?",
   "answers": ["UI rendering complexity", "Cost of the cloud", "Interactions and dependencies between services", "Coding difficulty within one module"],
   "correct": 2
 },
 {
   "question": "Which of the following is considered a downside of microservices?",
   "answers": ["Single codebase", "High infrastructure costs", "Fast deployments", "Less debugging effort"],
   "correct": 1
 },
 {
   "question": "In the context of microservices, 'local complexity' means:",
   "answers": ["The internal implementation of a service", "DNS routing", "Code reuse issues", "Micro UI rendering"],
   "correct": 0
 },
 {
   "question": "Why is debugging harder in microservices?",
   "answers": ["Because everything is stored in one file", "The logs are automatically deleted", "You have to trace across multiple services", "It lacks debugging tools"],
   "correct": 2
 },
{
   "question": "What is the “Big Ball of Mud” in architecture?",
   "answers": ["A monolithic CI/CD model", "An anti-pattern describing tangled, messy software structure", "A frontend rendering strategy", "A type of database"],
   "correct": 1
 },
 {
   "question": "Which situation is most likely to lead to a “Big Ball of Mud”?",
   "answers": ["Modular components", "Lack of service boundaries", "High test coverage", "Using serverless functions"],
   "correct": 1
 },
 {
   "question": "What’s a common risk when managing too many microservices?",
   "answers": ["Simple user flows", "Scalable infrastructure", "Over-complexity and tangled dependencies", "Fewer deployments"],
   "correct": 2
 },
{
   "question": "What role does an API Gateway play in microservices?",
   "answers": ["Backend-only deployment", "UI Rendering", "Authentication, throttling, orchestration", "Code deployment"],
   "correct": 2
 },
 {
   "question": "Which tool helps with caching in a microservices architecture?",
   "answers": ["Docker", "Redis", "Postman", "Webpack"],
   "correct": 1
 },
 {
   "question": "What do load balancers do?",
   "answers": ["Distribute traffic across services", "Secure APIs", "Replace caching", "Generate documentation"],
   "correct": 0
 },
 {
   "question": "Which of these is a good use-case for message queues in microservices?",
   "answers": ["UI design", "Database modeling", "Async communication between services", "Serving HTML"],
   "correct": 2
 },
 
 {
   "question": "What does the Richardson Maturity Model evaluate?",
   "answers": ["Frontend backend interaction", "API security level", "REST API's conformity to REST constraints", "HTTP method performance"],
   "correct": 2
 },
 {
   "question": "What’s the purpose of a CDN (Content Delivery Network)?",
   "answers": ["Run container orchestration", "Store logs", "Compile frontend code", "Cache and serve static content closer to users"],
   "correct": 3
 },
 {
   "question": "Which of the following contrasts with microservices in structure?",
   "answers": ["Distributed system", "CI/CD", "Monolithic architecture", "Component-based frontend"],
   "correct": 2
 },
 {
   "question": "What is the characteristic of Level-0 in the Richardson Maturity Model?",
   "answers": ["Uses PUT and DELETE", "One URI for the entire application", "Uses HTTP GET", "Multiple URIs"],
   "correct": 1
 },
 {
   "question": "What is the goal of BFF/BIF?",
   "answers": ["Write SOAP APIs", "Build a backend UI", "Tailor backend logic to the needs of each frontend", "Backend-only management"],
   "correct": 2
 },
 {
   "question": "Which of these technologies virtualizes hardware for software environments?",
   "answers": ["Kubernetes", "REST APIs", "Docker Compose", "Virtual Machines (VMs)"],
   "correct": 3
 },
 {
   "question": "Who proposed the Richardson Maturity Model?",
   "answers": ["Leonard Richardson", "Roy Fielding", "Tim Berners-Lee", "Martin Fowler"],
   "correct": 0
 },
 {
   "question": "What does BFF (Backend for Frontend) aim to do?",
   "answers": ["Deploy only CSS", "Run background jobs", "Debug the frontend", "Provide a backend optimized for each frontend"],
   "correct": 3
 },
 {
   "question": "Which of the following best describes Level-1 in the Richardson Maturity Model?",
   "answers": ["Uses JSON only", "Introduces resource-based URIs", "Uses HTTP Verbs", "Uses HATEOAS"],
   "correct": 1
 },
 {
   "question": "What are Micro Frontends?",
   "answers": ["Microservices applied to the frontend", "APIs for mobile apps", "Microservices for backend", "A CDN service"],
   "correct": 0
 },
 {
   "question": "At which level are HTTP methods like GET, POST, PUT, DELETE properly used?",
   "answers": ["Level-0", "Level-3", "Level-2", "Level-1"],
   "correct": 2
 },
 {
   "question": "What is Component-Based Architecture focused on?",
   "answers": ["Splitting applications into reusable pieces", "API-only development", "Storing logs", "Server virtualization"],
   "correct": 0
 },
 {
   "question": "Which of the following allows storage in the cloud?",
   "answers": ["Cloud Storage", "Git", "CDN", "VMs"],
   "correct": 0
 }

,
 {
   "question": "What is introduced at Level-3 of the Richardson Maturity Model?",
   "answers": ["HATEOAS", "JSON only", "XML", "OAuth"],
   "correct": 0
 },
 {
   "question": "Which HTTP method is used to retrieve a resource?",
   "answers": ["POST", "DELETE", "PUT", "GET"],
   "correct": 3
 },
 {
   "question": "Which HTTP method should you use to update an existing resource?",
   "answers": ["DELETE", "PUT", "POST", "HEAD"],
   "correct": 1
 },
 {
   "question": "What does the HTTP status code 200 mean?",
   "answers": ["Internal Server Error", "Resource Created", "OK", "Not Found"],
   "correct": 2
 },
 
 {
   "question": "Which status code indicates a server error?",
   "answers": ["500", "400", "201", "404"],
   "correct": 0
 },
 {
   "question": "What is HAL used for in REST?",
   "answers": ["Handling database transactions", "Creating HTML", "Structuring RESTful resources", "Frontend rendering"],
   "correct": 2
 },
 {
   "question": "Which of the following is not a best practice?",
   "answers": ["Accept and return JSON", "Make one massive URI with multiple actions", "Keep API consistent", "Use consistent HTTP status codes"],
   "correct": 1
 },
 {
   "question": "What is recommended as a response format for REST APIs?",
   "answers": ["HTML", "JSON", "XML only", "CSV"],
   "correct": 1
 },
 {
   "question": "What is a best practice when naming URIs?",
   "answers": ["Make them meaningful and resource-based", "Use port numbers", "Use camelCase", "Include action verbs"],
   "correct": 0
 },
 {
   "question": "Which HTTP header is used to specify the format of the data being sent?",
   "answers": ["Status-Code", "Content-Type", "Authorization", "Cache-Control"],
   "correct": 1
 },
 {
   "question": "Which of these is a lightweight, human-readable format used in REST APIs?",
   "answers": ["JSON", "CSV", "XML", "HTML"],
   "correct": 0
 },
 {
   "question": "Which is a commonly used authentication method for REST APIs?",
   "answers": ["OAuth", "SSL", "SHA256", "JSON"],
   "correct": 0
 },
     {
       "question": "What does JSON stand for?",
       "answers": ["Joint Structure of Objects Notation", "JavaScript Object Notation", "Java Sync Operation Network", "Java Source Object Notation"],
       "correct": 1
     },
     {
       "question": "What does a 404 HTTP status code represent?",
       "answers": ["Authorization failure", "Client error: resource not found", "Successful creation", "Server overload"],
       "correct": 1
     },
     {
       "question": "Before performing an API operation, what is a best practice?",
       "answers": ["Use only GET requests", "Avoid authentication", "Use proper headers and status codes", "Send everything as query params"],
       "correct": 2
     }
   ];

   const quizContainer = document.getElementById("quiz-container");

   questions.forEach((q, index) => {
     const div = document.createElement("div");
     div.innerHTML = `
       <p class="question">${index + 1}. ${q.question}</p>
       <ul class="answers">
         ${q.answers.map((answer, i) => `
           <li>
             <label>
               <input type="radio" name="q${index}" value="${i}" />
               ${answer}
             </label>
           </li>
         `).join("")}
       </ul>
     `;
     quizContainer.appendChild(div);
   });

   document.getElementById("quiz-form").addEventListener("submit", function(e) {
     e.preventDefault();
     let score = 0;
     const userAnswers = [];
     questions.forEach((q, index) => {
       const selected = document.querySelector(`input[name="q${index}"]:checked`);
       const container = document.getElementsByClassName("answers")[index];
       container.classList.remove("correct", "incorrect");

       if (selected) {
         userAnswers.push(parseInt(selected.value));
         if (parseInt(selected.value) === q.correct) {
           container.classList.add("correct");
           score++;
         } else {
           container.classList.add("incorrect");
         }
       } else {
         userAnswers.push(null);
         container.classList.add("incorrect");
       }
     });

     const resultDiv = document.getElementById("result");
     const percentage = (score / questions.length) * 100;
     resultDiv.textContent = `You scored ${percentage.toFixed(2)}% (${score} out of ${questions.length})`;

     if (percentage === 100) {
       resultDiv.textContent += " 🎉 Perfect!";
     } else if (percentage >= 50) {
       resultDiv.textContent += " 👍 Not bad!";
     } else {
       resultDiv.textContent += " 😬 Try again!";
     }
   });